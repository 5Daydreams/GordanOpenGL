#version 330 core

// type of output of this shader (vec4 for RGBA colour)
out vec4 FragColor;

// the "in" keyword means these values come from the associated vertex shader
in vec2 texCoord;
in vec3 Normal;
in vec3 FragPos;

uniform vec3 centerPos;
uniform vec3 camPos;

// Not the cleanest way, but this struct stores the lightcolor data from a single directional light source.
// Something to handle later will be handling multiple light sources
struct DirectionalLight {
    vec3 lightDir;
  
    // these values could be generated by scaling
    vec3 lightColor;
};

uniform DirectionalLight dirLight;
uniform sampler2D blendTexture;

uniform float highlightThreshold;
uniform float shadeThreshold;
uniform float textureEffect;

uniform vec3 highlightColor;
uniform vec3 keyColor;
uniform vec3 shadeColor;

uniform float time;
uniform vec2 renderTargetSize;

void main()
{
	float dirLightFalloff = dot(-dirLight.lightDir,normalize(Normal) );

	float satFalloff = max(dirLightFalloff,0.0f);

	vec2 screenUV = (gl_FragCoord.xy / renderTargetSize.xy);

	float textureDistScaling = distance(camPos,centerPos);
	
	screenUV.y += time/textureDistScaling;

	float noiseTextureValue = texture(blendTexture, 3.0* textureDistScaling * screenUV).r * 2.0f - 1.0f;

	float normalizedLightFalloff = (dirLightFalloff + 1.0f)*0.5f;

	// The multiplication is carried out here to block "false light" hitting the bottom of the mesh
	float lightValue = (textureEffect * noiseTextureValue * normalizedLightFalloff) + satFalloff;

	vec3 finalColor = keyColor;

	if(lightValue >= highlightThreshold)
	{
		finalColor = highlightColor;
	}
	else if (lightValue < shadeThreshold)
	{
		finalColor = shadeColor;
	}

	FragColor = vec4(finalColor * dirLight.lightColor, 1.0f);
}
